#!/bin/sh
# vim: set ft=sh

set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

source $(dirname $0)/common.sh

# for jq
PATH=/usr/local/bin:$PATH

payload=$TMPDIR/git-resource-request

cat > $payload <&0

load_pubkey $payload

uri=$(jq -r '.source.uri // ""' < $payload)
previous_branches_json=$(jq -r '.version.branches // ""' < $payload)

destination=$TMPDIR/git-resource-repo-cache

if echo $uri | grep -e '^/' ; then
  local_uri=true
else
  local_uri=false
fi

if [ -d $destination ]; then
  cd $destination
  git fetch
  git reset --hard FETCH_HEAD
else
  if $local_uri ; then
    # must omit --depth flag test suite otherwise local clone fails with RC=1
    git clone $uri $destination
  else
    # pass depth flag in actual use to avoid performance hit of cloning entire repo depth
    git clone --depth 1 $uri $destination
  fi
  cd $destination
fi

current_branches_list=$(git show-ref | grep 'refs/remotes/origin' | grep -v 'HEAD' | cut -d ' ' -f 2 | cut -d '/' -f 4)
current_branches_json=$(echo $current_branches_list | jq -R '. | split(" ")')
latest_version=$(jq -n "[{
  uri: $(echo $uri | jq -R .),
  branches: $current_branches_json
}]")

if [ "$previous_branches_json" == "$current_branches_json" ] ; then
  version="[]"
elif [ "$previous_branches_json" == '' ]; then
  version=$latest_version
else
  version=$latest_version
fi

echo $version >&3
